{"version":3,"mappings":"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","names":["__vitePreload","Segmenter","LeftSidePanel","ShadowlessElement","ele","html","css","__decorateClass","customElement","PagesPanel","WithDisposable","createPageBlock","workspace","pages","repeat","v","page","style","styleMap","click","deletePage","CloseIcon","property","id","createDefaultPage","_define_property","obj","key","value","CustomError","name","message","code","stack","Err_Cannot_find_a_running_iterator_with_given_ID","Err_Only_string_can_be_the_RPC_method_name","Err_Cannot_call_method_starts_with_rpc_dot_directly","Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options","Messages","makeHostedMessage","error","errors","DOMExceptionHeader","RecoverError","type","E","globalDOMException","e","removeStackHeader","isString","x","isBoolean","isFunction","isObject","params","ERROR","undefined$1","Promise_resolve","isArray","replayFunction","jsonrpc","Request","method","remoteStack","deleteUndefined","deleteFalsy","SuccessResponse","result","ErrorResponse","data","ErrorResponseParseError","mapper","ErrorResponseMapped","o","ErrorResponseInvalidRequest","ErrorResponseMethodNotFound","request","defaultErrorMapper","toString","ctor","isJSONRPCObject","_default","val","i","AsyncCallIgnoreResponse","AsyncCallNotify","AsyncCallBatch","generateRandomID","undefinedToTrue","normalizeLogOptions","log","beCalled","localError","remoteError","requestReplay","sendLocalStack","normalizeStrictOptions","strict","methodNotFound","unknownMessage","AsyncCall","thisSideImplementation","options","isThisSideImplementationPending","resolvedThisSideImplementationValue","rejectedThisSideImplementation","resolvedChannel","channelPromise","awaitThisSideImplementation","console_error","onChannelResolved","channel","isCallbackBasedChannel","rawMessageReceiver","rawMessageSender","_","deserialization","isEventBasedChannel","m","serializer","logKey","parameterStructures","preferLocalImplementation","idGenerator","mapError","logger","thenable","banMethodNotFound","banUnknownMessage","log_beCalled","log_localError","log_remoteError","log_pretty","log_requestReplay","log_sendLocalStack","console_log","console_debug","console_groupCollapsed","console_groupEnd","console_warn","requestContext","onRequest","makeErrorObject","frameworkStack","req_id","executor","args","promise","resolve","logArgs","replay","onResponse","errorMessage","remoteErrorStack","errorCode","errorType","detail","reject","localErrorStack","handleSingleMessage","res","reply","serialization","fstack","sendPayload","payload","removeQueueR","rejectsQueue","queue","ctx","r","call","notify","RPCInternalMethod","localImpl","param","getTrap","f","f2","methodContainer","instanceOfAny","object","constructors","c","idbProxyableTypes","cursorAdvanceMethods","getIdbProxyableTypes","getCursorAdvanceMethods","cursorRequestMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","promisifyRequest","unlisten","success","wrap","cacheDonePromiseForTransaction","tx","done","complete","idbProxyTraps","target","prop","receiver","replaceTraps","callback","wrapFunction","func","storeNames","unwrap","transformCachableValue","newValue","openDB","version","blocked","upgrade","blocking","terminated","openPromise","event","db","readMethods","writeMethods","cachedMethods","getMethod","targetFuncName","useIndex","isWrite","storeName","oldTraps","A","t","n","a","j","g","y","h","b","D","l","s","S","d","p","u","w","U","q","z","M","L","V","$","R","k","P","C","B","T","W"],"sources":["../../polyfill/intl-segmenter.ts","../../apps/starter/components/left-side-panel.ts","../../apps/starter/components/pages-panel.ts","../../../../node_modules/.pnpm/async-call-rpc@6.3.1/node_modules/async-call-rpc/out/base.mjs","../../../../node_modules/.pnpm/idb@7.1.1/node_modules/idb/build/wrap-idb-value.js","../../../../node_modules/.pnpm/idb@7.1.1/node_modules/idb/build/index.js","../../../../node_modules/.pnpm/y-provider@0.10.0-canary.9_yjs@13.6.11/node_modules/y-provider/dist/index.js","../../../../node_modules/.pnpm/@toeverything+y-indexeddb@0.10.0-canary.9_yjs@13.6.11/node_modules/@toeverything/y-indexeddb/dist/index.js"],"sourcesContent":["if (Intl.Segmenter === undefined) {\n  void import('intl-segmenter-polyfill-rs').then(({ Segmenter }) => {\n    Object.defineProperty(Intl, 'Segmenter', {\n      value: Segmenter,\n      configurable: true,\n      writable: true,\n    });\n  });\n}\n","import { ShadowlessElement } from '@blocksuite/lit';\nimport { css, html } from 'lit';\nimport { customElement } from 'lit/decorators.js';\n\n@customElement('left-side-panel')\nexport class LeftSidePanel extends ShadowlessElement {\n  static override styles = css`\n    left-side-panel {\n      padding-top: 50px;\n      width: 300px;\n      position: absolute;\n      top: 0;\n      left: 0;\n      height: 100%;\n      display: none;\n    }\n  `;\n  currentContent: HTMLElement | null = null;\n\n  showContent(ele: HTMLElement) {\n    if (this.currentContent) {\n      this.currentContent.remove();\n    }\n    this.style.display = 'block';\n    ele.classList.add('blocksuite-overlay');\n    this.currentContent = ele;\n    this.append(ele);\n  }\n\n  hideContent() {\n    if (this.currentContent) {\n      this.style.display = 'none';\n      this.currentContent.remove();\n      this.currentContent = null;\n    }\n  }\n\n  toggle(ele: HTMLElement) {\n    if (this.currentContent !== ele) {\n      this.showContent(ele);\n    } else {\n      this.hideContent();\n    }\n  }\n\n  protected override render(): unknown {\n    return html``;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'left-side-panel': LeftSidePanel;\n  }\n}\n","import { CloseIcon, createDefaultPage } from '@blocksuite/blocks';\nimport { ShadowlessElement, WithDisposable } from '@blocksuite/lit';\nimport type { AffineEditorContainer } from '@blocksuite/presets';\nimport type { Workspace } from '@blocksuite/store';\nimport { css, html } from 'lit';\nimport { customElement, property } from 'lit/decorators.js';\nimport { repeat } from 'lit/directives/repeat.js';\nimport { styleMap } from 'lit/directives/style-map.js';\n\n@customElement('pages-panel')\nexport class PagesPanel extends WithDisposable(ShadowlessElement) {\n  static override styles = css`\n    pages-panel {\n      display: flex;\n      flex-direction: column;\n      width: 100%;\n      background-color: var(--affine-background-secondary-color);\n      font-family: var(--affine-font-family);\n      height: 100%;\n      padding: 12px;\n      gap: 4px;\n    }\n    .page-item:hover .delete-page-icon {\n      display: flex;\n    }\n    .delete-page-icon {\n      display: none;\n      padding: 2px;\n      border-radius: 4px;\n    }\n    .delete-page-icon:hover {\n      background-color: var(--affine-hover-color);\n    }\n    .delete-page-icon svg {\n      width: 14px;\n      height: 14px;\n      color: var(--affine-secondary-color);\n      fill: var(--affine-secondary-color);\n    }\n    .new-page-button {\n      margin-bottom: 16px;\n      border: 1px solid var(--affine-border-color);\n      border-radius: 4px;\n      height: 32px;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      cursor: pointer;\n    }\n    .new-page-button:hover {\n      background-color: var(--affine-hover-color);\n    }\n  `;\n  @property({ attribute: false })\n  editor!: AffineEditorContainer;\n\n  public override connectedCallback() {\n    super.connectedCallback();\n    this.disposables.add(\n      this.editor.page.workspace.slots.pagesUpdated.on(() => {\n        this.requestUpdate();\n      })\n    );\n  }\n\n  createPage = () => {\n    createPageBlock(this.editor.page.workspace);\n  };\n\n  protected override render(): unknown {\n    const workspace = this.editor.page.workspace;\n    const pages = [...workspace.pages.values()];\n    return html`\n      <div @click=\"${this.createPage}\" class=\"new-page-button\">New Page</div>\n      ${repeat(\n        pages,\n        v => v.id,\n        page => {\n          const style = styleMap({\n            backgroundColor:\n              this.editor.page.id === page.id\n                ? 'var(--affine-hover-color)'\n                : undefined,\n            padding: '4px 4px 4px 8px',\n            borderRadius: '4px',\n            cursor: 'pointer',\n            display: 'flex',\n            justifyContent: 'space-between',\n          });\n          const click = () => {\n            this.editor.page = page;\n            this.editor.page.resetHistory();\n            this.requestUpdate();\n          };\n          const deletePage = () => {\n            workspace.removePage(page.id);\n            // When delete a page, we need to set the editor page to the first remaining page\n            const pages = Array.from(workspace.pages.values());\n            this.editor.page = pages[0];\n            this.requestUpdate();\n          };\n          return html`<div class=\"page-item\" @click=\"${click}\" style=\"${style}\">\n            ${page.meta.title || 'Untitled'}\n            <div @click=\"${deletePage}\" class=\"delete-page-icon\">\n              ${CloseIcon}\n            </div>\n          </div>`;\n        }\n      )}\n    `;\n  }\n}\n\nfunction createPageBlock(workspace: Workspace) {\n  const id = workspace.idGenerator();\n  createDefaultPage(workspace, { id }).catch(console.error);\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'pages-panel': PagesPanel;\n  }\n}\n","/// <reference types=\"./base.d.ts\" />\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nclass CustomError extends Error {\n    constructor(name, message, code, stack){\n        super(message);\n        _define_property(this, \"name\", void 0);\n        _define_property(this, \"code\", void 0);\n        _define_property(this, \"stack\", void 0);\n        this.name = name;\n        this.code = code;\n        this.stack = stack;\n    }\n}\nconst Err_Cannot_find_a_running_iterator_with_given_ID = {};\nconst Err_Only_string_can_be_the_RPC_method_name = {};\nconst Err_Cannot_call_method_starts_with_rpc_dot_directly = {};\nconst Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options = {};\nconst Messages = [\n    Err_Cannot_find_a_running_iterator_with_given_ID,\n    Err_Only_string_can_be_the_RPC_method_name,\n    Err_Cannot_call_method_starts_with_rpc_dot_directly,\n    Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options\n];\n// https://github.com/Jack-Works/async-call-rpc/wiki/Error-messages\nconst makeHostedMessage = (id, error)=>{\n    const n = Messages.indexOf(id);\n    error.message += `Error ${n}: https://github.com/Jack-Works/async-call-rpc/wiki/Errors#` + n;\n    return error;\n};\n// ! side effect\n/** These Error is defined in ECMAScript spec */ const errors = {\n    // @ts-expect-error\n    __proto__: null,\n    Error,\n    EvalError,\n    RangeError,\n    ReferenceError,\n    SyntaxError,\n    TypeError,\n    URIError\n};\nconst DOMExceptionHeader = 'DOMException:';\n/**\n * AsyncCall support somehow transfer ECMAScript Error\n */ const RecoverError = (type, message, code, stack)=>{\n    try {\n        const E = globalDOMException();\n        if (type.startsWith(DOMExceptionHeader) && E) {\n            const name = type.slice(DOMExceptionHeader.length);\n            return new E(message, name);\n        } else if (type in errors) {\n            const e = new errors[type](message);\n            e.stack = stack;\n            // @ts-expect-error\n            e.code = code;\n            return e;\n        } else {\n            return new CustomError(type, message, code, stack);\n        }\n    } catch (e) {\n        return new Error(`E${code} ${type}: ${message}\\n${stack}`);\n    }\n};\nconst removeStackHeader = (stack)=>String(stack).replace(/^.+\\n.+\\n/, '');\n// ! side effect\nconst globalDOMException = ()=>{\n    try {\n        // @ts-expect-error\n        return DOMException;\n    } catch (e) {}\n};\n\nconst isString = (x)=>typeof x === 'string';\nconst isBoolean = (x)=>typeof x === 'boolean';\nconst isFunction = (x)=>typeof x === 'function';\nconst isObject = (params)=>typeof params === 'object' && params !== null;\nconst ERROR = 'Error';\nconst undefined$1 = void 0;\nconst Promise_resolve = (x)=>Promise.resolve(x);\nconst isArray = Array.isArray;\nconst replayFunction = ()=>'() => replay()';\n\nconst jsonrpc = '2.0';\nconst Request = (id, method, params, remoteStack)=>{\n    const x = {\n        jsonrpc,\n        id,\n        method,\n        params,\n        remoteStack\n    };\n    deleteUndefined(x, 'id');\n    deleteFalsy(x, 'remoteStack');\n    return x;\n};\nconst SuccessResponse = (id, result)=>{\n    const x = {\n        jsonrpc,\n        id,\n        result\n    };\n    deleteUndefined(x, 'id');\n    return x;\n};\nconst ErrorResponse = (id, code, message, data)=>{\n    if (id === undefined$1) id = null;\n    code = Math.floor(code);\n    if (Number.isNaN(code)) code = -1;\n    const x = {\n        jsonrpc,\n        id,\n        error: {\n            code,\n            message,\n            data\n        }\n    };\n    deleteUndefined(x.error, 'data');\n    return x;\n};\n// Pre defined error in section 5.1\n// ! side effect\nconst ErrorResponseParseError = (e, mapper)=>{\n    const obj = ErrorResponseMapped({}, e, mapper);\n    const o = obj.error;\n    o.code = -32700;\n    o.message = 'Parse error';\n    return obj;\n};\n// Not using.\n// InvalidParams -32602 'Invalid params'\n// InternalError -32603 'Internal error'\nconst ErrorResponseInvalidRequest = (id)=>ErrorResponse(id, -32600, 'Invalid Request');\nconst ErrorResponseMethodNotFound = (id)=>ErrorResponse(id, -32601, 'Method not found');\nconst ErrorResponseMapped = (request, e, mapper)=>{\n    const { id  } = request;\n    const { code , message , data  } = mapper(e, request);\n    return ErrorResponse(id, code, message, data);\n};\nconst defaultErrorMapper = (stack = '', code = -1)=>(e)=>{\n        let message = toString('', ()=>e.message);\n        let type = toString(ERROR, (ctor = e.constructor)=>isFunction(ctor) && ctor.name);\n        const E = globalDOMException();\n        if (E && e instanceof E) type = DOMExceptionHeader + e.name;\n        if (isString(e) || typeof e === 'number' || isBoolean(e) || typeof e === 'bigint') {\n            type = ERROR;\n            message = String(e);\n        }\n        const data = stack ? {\n            stack,\n            type\n        } : {\n            type\n        };\n        return {\n            code,\n            message,\n            data\n        };\n    };\nconst isJSONRPCObject = (data)=>{\n    if (!isObject(data)) return false;\n    if (!('jsonrpc' in data)) return false;\n    if (data.jsonrpc !== jsonrpc) return false;\n    if ('params' in data) {\n        const params = data.params;\n        if (!isArray(params) && !isObject(params)) return false;\n    }\n    return true;\n};\nconst toString = (_default, val)=>{\n    try {\n        const v = val();\n        if (v === undefined$1) return _default;\n        return String(v);\n    } catch (e) {\n        return _default;\n    }\n};\nconst deleteUndefined = (x, key)=>{\n    if (x[key] === undefined$1) delete x[key];\n};\nconst deleteFalsy = (x, key)=>{\n    if (!x[key]) delete x[key];\n};\n\n//#region Serialization\n/**\n * Serialization implementation that do nothing\n * @remarks {@link Serialization}\n * @public\n * @deprecated Will be removed in next major version\n */ const NoSerialization = {\n    serialization (from) {\n        return from;\n    },\n    deserialization (serialized) {\n        return serialized;\n    }\n};\n/**\n * Create a serialization by JSON.parse/stringify\n *\n * @param replacerAndReceiver - Replacer and receiver of JSON.parse/stringify\n * @param space - Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n * @param undefinedKeepingBehavior - How to keep \"undefined\" in result of SuccessResponse?\n *\n * If it is not handled properly, JSON.stringify will emit an invalid JSON RPC object.\n *\n * Options:\n * - `\"null\"`(**default**): convert it to null.\n * - `\"keep\"`: try to keep it by additional property \"undef\".\n * - `false`: Don't keep it, let it break.\n * @remarks {@link Serialization}\n * @public\n */ const JSONSerialization = (replacerAndReceiver = [\n    undefined$1,\n    undefined$1\n], space, undefinedKeepingBehavior = 'null')=>({\n        serialization (from) {\n            if (undefinedKeepingBehavior && isObject(from) && 'result' in from && from.result === undefined$1) {\n                const alt = {\n                    ...from\n                };\n                alt.result = null;\n                if (undefinedKeepingBehavior === 'keep') alt.undef = true;\n                from = alt;\n            }\n            return JSON.stringify(from, replacerAndReceiver[0], space);\n        },\n        deserialization (serialized) {\n            const result = JSON.parse(serialized, replacerAndReceiver[1]);\n            if (isObject(result) && 'result' in result && result.result === null && 'undef' in result && result.undef === true) {\n                result.result = undefined$1;\n                delete result.undef;\n            }\n            return result;\n        }\n    } //#endregion\n    );\n\nconst i = 'AsyncCall/';\n// ! side effect\nconst AsyncCallIgnoreResponse = Symbol.for(i + 'ignored');\nconst AsyncCallNotify = Symbol.for(i + 'notify');\nconst AsyncCallBatch = Symbol.for(i + 'batch');\n\n/**\n * Wrap the AsyncCall instance to send notification.\n * @param instanceOrFnOnInstance - The AsyncCall instance or function on the AsyncCall instance\n * @example\n * const notifyOnly = notify(AsyncCall(...))\n * @public\n */ function notify(instanceOrFnOnInstance) {\n    if (isFunction(instanceOrFnOnInstance)) return instanceOrFnOnInstance[AsyncCallNotify];\n    return new Proxy(instanceOrFnOnInstance, {\n        get: notifyTrap\n    });\n}\nconst notifyTrap = (target, p)=>{\n    return target[p][AsyncCallNotify];\n};\n\n/**\n * Wrap the AsyncCall instance to use batch call.\n * @param asyncCallInstance - The AsyncCall instance\n * @example\n * const [batched, send, drop] = batch(AsyncCall(...))\n * batched.call1() // pending\n * batched.call2() // pending\n * send() // send all pending requests\n * drop() // drop all pending requests\n * @returns It will return a tuple.\n *\n * The first item is the batched version of AsyncCall instance passed in.\n *\n * The second item is a function to send all pending requests.\n *\n * The third item is a function to drop and reject all pending requests.\n * @public\n */ function batch(asyncCallInstance) {\n    const queue = [];\n    const getTrap = new Proxy({}, {\n        get (_, p) {\n            // @ts-expect-error\n            const f = (...args)=>asyncCallInstance[AsyncCallBatch](queue, p, ...args);\n            // @ts-expect-error\n            f[AsyncCallNotify] = (...args)=>// @ts-expect-error\n                asyncCallInstance[AsyncCallBatch][AsyncCallNotify](queue, p, ...args);\n            // @ts-expect-error\n            f[AsyncCallNotify][AsyncCallNotify] = f[AsyncCallNotify];\n            isString(p) && Object.defineProperty(methodContainer, p, {\n                value: f,\n                configurable: true\n            });\n            return f;\n        }\n    });\n    const methodContainer = {\n        __proto__: getTrap\n    };\n    return [\n        new Proxy(methodContainer, {\n            getPrototypeOf: ()=>null,\n            setPrototypeOf: (_, value)=>value === null\n        }),\n        ()=>{\n            queue.length && queue.r[0]();\n            queue.length = 0;\n        },\n        (error = new Error('Aborted'))=>{\n            queue.length && queue.r[1](error);\n            queue.length = 0;\n        }\n    ];\n}\n\nconst generateRandomID = ()=>Math.random().toString(36).slice(2);\n\nconst undefinedToTrue = (x)=>x === void 0 ? true : x;\nconst normalizeLogOptions = (log)=>{\n    if (log === 'all') return [\n        true,\n        true,\n        true,\n        true,\n        true,\n        true\n    ];\n    if (!isBoolean(log)) {\n        const { beCalled , localError , remoteError , type , requestReplay , sendLocalStack  } = log;\n        return [\n            undefinedToTrue(beCalled),\n            undefinedToTrue(localError),\n            undefinedToTrue(remoteError),\n            type !== 'basic',\n            requestReplay,\n            sendLocalStack\n        ];\n    }\n    if (log) return [\n        true,\n        true,\n        true,\n        true\n    ];\n    return [];\n};\nconst normalizeStrictOptions = (strict)=>{\n    if (!isBoolean(strict)) {\n        const { methodNotFound , unknownMessage  } = strict;\n        return [\n            methodNotFound,\n            unknownMessage\n        ];\n    }\n    return [\n        strict,\n        strict\n    ];\n};\n\n/**\n * Create a RPC server & client.\n *\n * @remarks\n * See {@link AsyncCallOptions}\n *\n * thisSideImplementation can be a Promise so you can write:\n *\n * ```ts\n * export const service = AsyncCall(typeof window === 'object' ? {} : import('./backend/service.js'), {})\n * ```\n *\n * @param thisSideImplementation - The implementation when this AsyncCall acts as a JSON RPC server. Can be a Promise.\n * @param options - {@link AsyncCallOptions}\n * @typeParam OtherSideImplementedFunctions - The type of the API that server expose. For any function on this interface, it will be converted to the async version.\n * @returns Same as the `OtherSideImplementedFunctions` type parameter, but every function in that interface becomes async and non-function value is removed. Method called \"then\" are also removed.\n * @public\n */ function AsyncCall(thisSideImplementation, options) {\n    let isThisSideImplementationPending = true;\n    let resolvedThisSideImplementationValue;\n    let rejectedThisSideImplementation;\n    let resolvedChannel;\n    let channelPromise;\n    // This promise should never fail\n    const awaitThisSideImplementation = async ()=>{\n        try {\n            resolvedThisSideImplementationValue = await thisSideImplementation;\n        } catch (e) {\n            rejectedThisSideImplementation = e;\n            console_error('AsyncCall failed to start', e);\n        } finally{\n            isThisSideImplementationPending = false;\n        }\n    };\n    const onChannelResolved = (channel)=>{\n        resolvedChannel = channel;\n        if (isCallbackBasedChannel(channel)) {\n            channel.setup((data)=>rawMessageReceiver(data).then(rawMessageSender), (data)=>{\n                const _ = deserialization(data);\n                if (isJSONRPCObject(_)) return true;\n                return Promise_resolve(_).then(isJSONRPCObject);\n            });\n        }\n        if (isEventBasedChannel(channel)) {\n            const m = channel;\n            m.on && m.on((_)=>rawMessageReceiver(_).then(rawMessageSender).then((x)=>x && m.send(x)));\n        }\n        return channel;\n    };\n    const { serializer , key: logKey = 'rpc' , strict =true , log =true , parameterStructures ='by-position' , preferLocalImplementation =false , idGenerator =generateRandomID , mapError , logger , channel , thenable  } = options;\n    if (thisSideImplementation instanceof Promise) awaitThisSideImplementation();\n    else {\n        resolvedThisSideImplementationValue = thisSideImplementation;\n        isThisSideImplementationPending = false;\n    }\n    const [banMethodNotFound, banUnknownMessage] = normalizeStrictOptions(strict);\n    const [log_beCalled, log_localError, log_remoteError, log_pretty, log_requestReplay, log_sendLocalStack] = normalizeLogOptions(log);\n    const { log: console_log , error: console_error = console_log , debug: console_debug = console_log , groupCollapsed: console_groupCollapsed = console_log , groupEnd: console_groupEnd = console_log , warn: console_warn = console_log  } = logger || console;\n    const requestContext = new Map();\n    const onRequest = async (data)=>{\n        if (isThisSideImplementationPending) await awaitThisSideImplementation();\n        else {\n            // not pending\n            if (rejectedThisSideImplementation) return makeErrorObject(rejectedThisSideImplementation, '', data);\n        }\n        let frameworkStack = '';\n        try {\n            const { params , method , id: req_id , remoteStack  } = data;\n            // ? We're mapping any method starts with 'rpc.' to a Symbol.for\n            const key = method.startsWith('rpc.') ? Symbol.for(method) : method;\n            const executor = resolvedThisSideImplementationValue && resolvedThisSideImplementationValue[key];\n            if (!isFunction(executor)) {\n                if (!banMethodNotFound) {\n                    if (log_localError) console_debug('Missing method', key, data);\n                    return;\n                } else return ErrorResponseMethodNotFound(req_id);\n            }\n            const args = isArray(params) ? params : [\n                params\n            ];\n            frameworkStack = removeStackHeader(new Error().stack);\n            const promise = new Promise((resolve)=>resolve(executor.apply(resolvedThisSideImplementationValue, args)));\n            if (log_beCalled) {\n                if (log_pretty) {\n                    const logArgs = [\n                        `${logKey}.%c${method}%c(${args.map(()=>'%o').join(', ')}%c)\\n%o %c@${req_id}`,\n                        'color: #d2c057',\n                        '',\n                        ...args,\n                        '',\n                        promise,\n                        'color: gray; font-style: italic;'\n                    ];\n                    if (log_requestReplay) {\n                        // This function will be logged to the console so it must be 1 line\n                        // prettier-ignore\n                        const replay = ()=>{\n                            debugger;\n                            return executor.apply(resolvedThisSideImplementationValue, args);\n                        };\n                        replay.toString = replayFunction;\n                        logArgs.push(replay);\n                    }\n                    if (remoteStack) {\n                        console_groupCollapsed(...logArgs);\n                        console_log(remoteStack);\n                        console_groupEnd();\n                    } else console_log(...logArgs);\n                } else console_log(`${logKey}.${method}(${[\n                    ...args\n                ].toString()}) @${req_id}`);\n            }\n            const result = await promise;\n            if (result === AsyncCallIgnoreResponse) return;\n            return SuccessResponse(req_id, result);\n        } catch (e) {\n            return makeErrorObject(e, frameworkStack, data);\n        }\n    };\n    const onResponse = async (data)=>{\n        let errorMessage = '', remoteErrorStack = '', errorCode = 0, errorType = ERROR;\n        if ('error' in data) {\n            const e = data.error;\n            errorMessage = e.message;\n            errorCode = e.code;\n            const detail = e.data;\n            if (isObject(detail) && 'stack' in detail && isString(detail.stack)) remoteErrorStack = detail.stack;\n            else remoteErrorStack = '<remote stack not available>';\n            if (isObject(detail) && 'type' in detail && isString(detail.type)) errorType = detail.type;\n            else errorType = ERROR;\n            if (log_remoteError) log_pretty ? console_error(`${errorType}: ${errorMessage}(${errorCode}) %c@${data.id}\\n%c${remoteErrorStack}`, 'color: gray', '') : console_error(`${errorType}: ${errorMessage}(${errorCode}) @${data.id}\\n${remoteErrorStack}`);\n        }\n        const { id  } = data;\n        if (id === null || id === undefined$1 || !requestContext.has(id)) return;\n        const [resolve, reject, localErrorStack = ''] = requestContext.get(id);\n        requestContext.delete(id);\n        if ('error' in data) {\n            reject(RecoverError(errorType, errorMessage, errorCode, // ? We use \\u0430 which looks like \"a\" to prevent browser think \"at AsyncCall\" is a real stack\n            remoteErrorStack + '\\n    \\u0430t AsyncCall (rpc) \\n' + localErrorStack));\n        } else {\n            resolve(data.result);\n        }\n        return;\n    };\n    const rawMessageReceiver = async (_)=>{\n        let data;\n        let result = undefined$1;\n        try {\n            data = await deserialization(_);\n            if (isJSONRPCObject(data)) {\n                return result = await handleSingleMessage(data);\n            } else if (isArray(data) && data.every(isJSONRPCObject) && data.length !== 0) {\n                return Promise.all(data.map(handleSingleMessage));\n            } else {\n                if (banUnknownMessage) {\n                    let id = data.id;\n                    if (id === undefined$1) id = null;\n                    return ErrorResponseInvalidRequest(id);\n                } else {\n                    // ? Ignore this message. The message channel maybe also used to transfer other message too.\n                    return undefined$1;\n                }\n            }\n        } catch (e) {\n            if (log_localError) console_error(e, data, result);\n            // todo: should check before access e.stack\n            return ErrorResponseParseError(e, mapError || defaultErrorMapper(e && e.stack));\n        }\n    };\n    const rawMessageSender = async (res)=>{\n        if (!res) return;\n        if (isArray(res)) {\n            const reply = res.filter((x)=>x && 'id' in x);\n            if (reply.length === 0) return;\n            return serialization(reply);\n        } else {\n            return serialization(res);\n        }\n    };\n    const serialization = serializer ? (x)=>serializer.serialization(x) : Object;\n    const deserialization = serializer ? (x)=>serializer.deserialization(x) : Object;\n    if (channel instanceof Promise) channelPromise = channel.then(onChannelResolved);\n    else onChannelResolved(channel);\n    const makeErrorObject = (e, frameworkStack, data)=>{\n        if (isObject(e) && 'stack' in e) e.stack = frameworkStack.split('\\n').reduce((stack, fstack)=>stack.replace(fstack + '\\n', ''), '' + e.stack);\n        if (log_localError) console_error(e);\n        return ErrorResponseMapped(data, e, mapError || defaultErrorMapper(log_sendLocalStack ? e.stack : undefined$1));\n    };\n    const sendPayload = async (payload, removeQueueR = false)=>{\n        if (removeQueueR) payload = [\n            ...payload\n        ];\n        const data = await serialization(payload);\n        return (resolvedChannel || await channelPromise).send(data);\n    };\n    const rejectsQueue = (queue, error)=>{\n        for (const x of queue){\n            if ('id' in x) {\n                const ctx = requestContext.get(x.id);\n                ctx && ctx[1](error);\n            }\n        }\n    };\n    const handleSingleMessage = async (data)=>{\n        if ('method' in data) {\n            const r = onRequest(data);\n            if ('id' in data) return r;\n            try {\n                await r;\n            } catch (e) {}\n            return undefined$1 // Does not care about return result for notifications\n            ;\n        }\n        return onResponse(data);\n    };\n    const call = (method, args, stack, notify = false)=>{\n        return new Promise((resolve, reject)=>{\n            let queue = undefined$1;\n            if (method === AsyncCallBatch) {\n                queue = args.shift();\n                method = args.shift();\n            }\n            if (typeof method === 'symbol') {\n                const RPCInternalMethod = Symbol.keyFor(method) || method.description;\n                if (RPCInternalMethod) {\n                    if (RPCInternalMethod.startsWith('rpc.')) method = RPCInternalMethod;\n                    else throw new TypeError('Not start with rpc.');\n                }\n            } else if (method.startsWith('rpc.')) {\n                throw makeHostedMessage(Err_Cannot_call_method_starts_with_rpc_dot_directly, new TypeError());\n            }\n            if (preferLocalImplementation && !isThisSideImplementationPending && isString(method)) {\n                const localImpl = resolvedThisSideImplementationValue && resolvedThisSideImplementationValue[method];\n                if (isFunction(localImpl)) return resolve(localImpl(...args));\n            }\n            const id = idGenerator();\n            stack = removeStackHeader(stack);\n            const param = parameterStructures === 'by-name' && args.length === 1 && isObject(args[0]) ? args[0] : args;\n            const request = Request(notify ? undefined$1 : id, method, param, log_sendLocalStack ? stack : undefined$1);\n            if (queue) {\n                queue.push(request);\n                if (!queue.r) queue.r = [\n                    ()=>sendPayload(queue, true),\n                    (e)=>rejectsQueue(queue, e)\n                ];\n            } else sendPayload(request).catch(reject);\n            if (notify) return resolve();\n            requestContext.set(id, [\n                resolve,\n                reject,\n                stack\n            ]);\n        });\n    };\n    const getTrap = (_, method)=>{\n        const f = {\n            // This function will be logged to the console so it must be 1 line\n            [method]: (..._)=>call(method, _, new Error().stack)\n        }[method];\n        const f2 = {\n            [method]: (..._)=>call(method, _, new Error().stack, true)\n        }[method];\n        // @ts-expect-error\n        f[AsyncCallNotify] = f2[AsyncCallNotify] = f2;\n        isString(method) && Object.defineProperty(methodContainer, method, {\n            value: f,\n            configurable: true\n        });\n        return f;\n    };\n    const methodContainer = {\n        __proto__: new Proxy({}, {\n            get: getTrap\n        })\n    };\n    if (thenable === false) methodContainer.then = undefined$1;\n    else if (thenable === undefined$1) {\n        Object.defineProperty(methodContainer, 'then', {\n            configurable: true,\n            get () {\n                console_warn(makeHostedMessage(Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options, new TypeError('RPC used as Promise: ')));\n            }\n        });\n    }\n    return new Proxy(methodContainer, {\n        getPrototypeOf: ()=>null,\n        setPrototypeOf: (_, value)=>value === null,\n        // some library will treat this object as a normal object and run algorithm steps in https://tc39.es/ecma262/#sec-ordinaryget\n        getOwnPropertyDescriptor (_, method) {\n            if (!(method in methodContainer)) getTrap(_, method) // trigger [[Get]]\n            ;\n            return Object.getOwnPropertyDescriptor(methodContainer, method);\n        }\n    });\n}\nconst isEventBasedChannel = (x)=>'send' in x && isFunction(x.send);\nconst isCallbackBasedChannel = (x)=>'setup' in x && isFunction(x.setup);\n\nexport { AsyncCall, JSONSerialization, NoSerialization, batch, notify };\n//# sourceMappingURL=base.mjs.map\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","import { applyUpdate as m, encodeStateAsUpdate as q, encodeStateVector as z } from \"yjs\";\nasync function I(t, n) {\n  const r = async (a) => {\n    const o = await n.queryDocState(a.guid);\n    o && m(a, o.missing, \"sync-doc-from-datasource\"), await Promise.all(\n      [...a.subdocs].map(async (f) => {\n        await r(f);\n      })\n    );\n  };\n  await r(t);\n}\nasync function O(t, n) {\n  const r = async (a) => {\n    await n.sendDocUpdate(a.guid, q(a)), await Promise.all(\n      [...a.subdocs].map(async (o) => {\n        await r(o);\n      })\n    );\n  };\n  await r(t);\n}\nasync function W(t, n, r) {\n  const a = t();\n  await Promise.all(\n    a.map((o) => r.queryDocState(o).then(async (f) => {\n      const g = await (async () => f ? n.queryDocState(o, {\n        stateVector: f.state\n      }) : n.queryDocState(o))();\n      if (g) {\n        const y = g.missing;\n        if (y.length === 2 && y[0] === 0 && y[1] === 0)\n          return;\n        await r.sendDocUpdate(o, g.missing);\n      }\n    }))\n  );\n}\nfunction A(t, n = \"val does not exist\") {\n  if (t == null)\n    throw n instanceof Error ? n : new Error(n);\n}\nfunction x(t, n) {\n  if (t.guid === n)\n    return t;\n  for (const r of t.subdocs) {\n    const a = x(r, n);\n    if (a)\n      return a;\n  }\n}\nconst j = (t, n, r = {}) => {\n  let a = !1;\n  const o = /* @__PURE__ */ new Map(), f = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Set();\n  let y = null;\n  const { origin: h = \"lazy-provider\" } = r;\n  let b = {\n    type: \"idle\"\n  }, D = 0;\n  const v = /* @__PURE__ */ new Set(), l = (e) => {\n    e.type === \"syncing\" ? D++ : (e.type === \"synced\" || e.type === \"error\") && D--, D < 0 && console.error(\n      \"syncingStatus < 0, this should not happen\",\n      r.origin\n    ), D === 0 && (b = e), e.type !== \"synced\" && (b = e), D === 0 && (a ? b = {\n      type: \"synced\"\n    } : b = {\n      type: \"idle\"\n    }), v.forEach((s) => s());\n  };\n  async function S(e) {\n    const s = e.guid;\n    {\n      const c = s.startsWith(\"space:\") ? s.slice(6) : s, d = `${t.guid}:space:${c}`, p = `space:${c}`, u = await n.queryDocState(d), w = await n.queryDocState(p);\n      let U = !1;\n      u && u.missing.length !== 2 && u.missing[0] !== 0 && u.missing[1] !== 0 && (m(e, u.missing, h), U = !0), w && w.missing.length !== 2 && w.missing[0] !== 0 && w.missing[1] !== 0 && (m(e, w.missing, h), U = !0), U && await n.sendDocUpdate(\n        s,\n        q(\n          e,\n          u ? u.state : w ? w.state : void 0\n        )\n      );\n    }\n    if (!a)\n      return;\n    l({\n      type: \"syncing\"\n    });\n    const i = await n.queryDocState(s, {\n      stateVector: z(e)\n    }).then((c) => (l({\n      type: \"synced\"\n    }), c)).catch((c) => {\n      throw l({\n        type: \"error\",\n        error: c\n      }), c;\n    });\n    o.set(s, []), i && m(e, i.missing, h), a && (await n.sendDocUpdate(\n      s,\n      q(e, i ? i.state : void 0)\n    ), e.emit(\"sync\", []));\n  }\n  function M(e) {\n    const s = /* @__PURE__ */ new Set();\n    f.set(e.guid, s);\n    const i = async (d, p) => {\n      h !== p && (l({\n        type: \"syncing\"\n      }), n.sendDocUpdate(e.guid, d).then(() => {\n        l({\n          type: \"synced\"\n        });\n      }).catch((u) => {\n        l({\n          type: \"error\",\n          error: u\n        }), console.error(u);\n      }));\n    }, c = (d) => {\n      d.loaded.forEach((p) => {\n        E(p).catch(console.error);\n      }), d.removed.forEach((p) => {\n        L(p);\n      });\n    };\n    e.on(\"update\", i), e.on(\"subdocs\", c), s.add(() => {\n      e.off(\"update\", i), e.off(\"subdocs\", c);\n    });\n  }\n  function V() {\n    var s;\n    A(y, \"abortController should be defined\");\n    const e = (s = n.onDocUpdate) == null ? void 0 : s.call(n, (i, c) => {\n      var p;\n      l({\n        type: \"syncing\"\n      });\n      const d = x(t, i);\n      d ? (m(d, c, h), o.has(i) && ((p = o.get(i)) == null || p.forEach((u) => m(d, u, h)), o.delete(i))) : (console.warn(\"doc not found\", i), o.set(i, (o.get(i) ?? []).concat(c))), l({\n        type: \"synced\"\n      });\n    });\n    y.signal.addEventListener(\"abort\", () => {\n      e == null || e();\n    });\n  }\n  async function E(e) {\n    g.has(e.guid) || (g.add(e.guid), M(e), await S(e), await Promise.all(\n      [...e.subdocs].filter((s) => s.shouldLoad).map((s) => E(s))\n    ));\n  }\n  function L(e) {\n    g.delete(e.guid);\n    const s = f.get(e.guid);\n    s && (s.forEach((i) => i()), f.delete(e.guid)), e.subdocs.forEach(L);\n  }\n  function $() {\n    f.forEach((e) => {\n      e.forEach((s) => s());\n    }), f.clear(), g.clear();\n  }\n  function R() {\n    a = !0, y = new AbortController(), l({\n      type: \"syncing\"\n    }), E(t).then(() => {\n      l({\n        type: \"synced\"\n      });\n    }).catch((e) => {\n      l({\n        type: \"error\",\n        error: e\n      }), console.error(e);\n    }), V();\n  }\n  async function k() {\n    a = !1, $(), A(y, \"abortController should be defined\"), y.abort(), y = null;\n  }\n  const P = async (e) => {\n    await S(e), await Promise.all(\n      [...e.subdocs.values()].map((s) => P(s))\n    );\n  };\n  return {\n    sync: async (e) => {\n      a = !0;\n      try {\n        e ? await S(t) : await P(t);\n      } finally {\n        a = !1;\n      }\n    },\n    get status() {\n      return b;\n    },\n    subscribeStatusChange(e) {\n      return v.add(e), () => {\n        v.delete(e);\n      };\n    },\n    get connected() {\n      return a;\n    },\n    passive: !0,\n    connect: R,\n    disconnect: k,\n    datasource: n\n  };\n};\nfunction F(t, n) {\n  if (t.guid === n)\n    return t;\n  for (const r of t.subdocs) {\n    const a = F(r, n);\n    if (a)\n      return a;\n  }\n}\nconst C = (t) => (t.preventDefault(), t.returnValue = \"Data is not saved. Are you sure you want to leave?\"), B = async (t) => {\n  window.addEventListener(\"beforeunload\", C, {\n    capture: !0\n  }), await t, window.removeEventListener(\"beforeunload\", C, {\n    capture: !0\n  });\n};\nexport {\n  j as createLazyProvider,\n  F as getDoc,\n  W as syncDataSource,\n  O as syncDataSourceFromDoc,\n  I as syncDocFromDataSource,\n  B as writeOperation\n};\n//# sourceMappingURL=index.js.map\n","import { openDB as p } from \"idb\";\nimport { Doc as A, applyUpdate as S, encodeStateAsUpdate as D, diffUpdate as U, encodeStateVectorFromUpdate as B, encodeStateVector as P, UndoManager as M } from \"yjs\";\nimport { writeOperation as C, createLazyProvider as V } from \"y-provider\";\nconst m = 1, l = \"affine-local\";\nfunction f(e) {\n  e.createObjectStore(\"workspace\", { keyPath: \"id\" }), e.createObjectStore(\"milestone\", { keyPath: \"id\" });\n}\nfunction E(e, n = \"val does not exist\") {\n  if (e == null)\n    throw n instanceof Error ? n : new Error(n);\n}\nlet y;\nfunction g(e) {\n  const n = new A();\n  return e.forEach((a) => {\n    S(n, a);\n  }), D(n);\n}\nasync function O(e) {\n  return new Promise((n) => {\n    const a = indexedDB.open(e);\n    let t = !0;\n    a.onsuccess = function() {\n      a.result.close(), t || indexedDB.deleteDatabase(e), n(t);\n    }, a.onupgradeneeded = function() {\n      t = !1;\n    };\n  });\n}\nasync function q(e, n, a = l) {\n  do\n    if (!y || localStorage.getItem(`${a}-migration`) !== \"true\") {\n      try {\n        y = await indexedDB.databases();\n      } catch {\n        if (await O(n)) {\n          await p(n, 1).then(async (t) => {\n            if (!t.objectStoreNames.contains(\"updates\"))\n              return;\n            const r = await t.transaction(\"updates\", \"readonly\").objectStore(\"updates\").getAll();\n            if (!Array.isArray(r) || !r.every((d) => d instanceof Uint8Array))\n              return;\n            const o = g(r), i = e.transaction(\"workspace\", \"readwrite\").objectStore(\"workspace\");\n            await i.get(n) || (console.log(\"upgrading the database\"), await i.put({\n              id: n,\n              updates: [\n                {\n                  timestamp: Date.now(),\n                  update: o\n                }\n              ]\n            }));\n          });\n          break;\n        }\n      }\n      await Promise.all(\n        y && y.map((t) => {\n          if (t.name && t.version === 1) {\n            const c = t.name, r = t.version;\n            return p(c, r).then(\n              async (o) => {\n                if (!o.objectStoreNames.contains(\"updates\"))\n                  return;\n                const s = await o.transaction(\"updates\", \"readonly\").objectStore(\"updates\").getAll();\n                if (!Array.isArray(s) || !s.every((b) => b instanceof Uint8Array))\n                  return;\n                const d = g(s), u = e.transaction(\"workspace\", \"readwrite\").objectStore(\"workspace\");\n                await u.get(c) || (console.log(\"upgrading the database\"), await u.put({\n                  id: c,\n                  updates: [\n                    {\n                      timestamp: Date.now(),\n                      update: d\n                    }\n                  ]\n                }));\n              }\n            );\n          }\n        })\n      ), localStorage.setItem(`${a}-migration`, \"true\");\n      break;\n    }\n  while (!1);\n}\nasync function F(e, n = l) {\n  const r = await (await p(n, m, {\n    upgrade: f\n  })).transaction(\"workspace\", \"readonly\").objectStore(\"workspace\").get(e);\n  return r ? g(r.updates.map(({ update: o }) => o)) : !1;\n}\nasync function N(e, n, a = l) {\n  await (await p(a, m, {\n    upgrade: f\n  })).transaction(\"workspace\", \"readwrite\").objectStore(\"workspace\").put({\n    id: e,\n    updates: [\n      {\n        timestamp: Date.now(),\n        update: n\n      }\n    ]\n  });\n}\nasync function _(e, n, a = l) {\n  const r = (await p(a, m, {\n    upgrade: f\n  })).transaction(\"workspace\", \"readwrite\").objectStore(\"workspace\"), o = await r.get(e);\n  o ? (o.updates.push({\n    timestamp: Date.now(),\n    update: n\n  }), await r.put(o)) : await r.put({\n    id: e,\n    updates: [\n      {\n        timestamp: Date.now(),\n        update: n\n      }\n    ]\n  });\n}\nlet v = 500;\nfunction z(e) {\n  v = e;\n}\nconst T = ({\n  dbName: e = l,\n  mergeCount: n\n}) => {\n  let a = null;\n  const t = async () => (a === null && (a = p(e, m, {\n    upgrade: f\n  })), a);\n  return {\n    ...{\n      queryDocState: async (r, o) => {\n        var i;\n        try {\n          const u = await (await t()).transaction(\"workspace\", \"readonly\").objectStore(\"workspace\").get(r);\n          if (!u)\n            return !1;\n          const { updates: w } = u, b = g(w.map(({ update: x }) => x));\n          return { missing: o != null && o.stateVector ? U(b, o == null ? void 0 : o.stateVector) : b, state: B(b) };\n        } catch (s) {\n          if (!((i = s.message) != null && i.includes(\"The database connection is closing.\")))\n            throw s;\n          return !1;\n        }\n      },\n      sendDocUpdate: async (r, o) => {\n        var i;\n        try {\n          const d = (await t()).transaction(\"workspace\", \"readwrite\").objectStore(\"workspace\"), { updates: u } = await d.get(r) ?? { updates: [] };\n          let w = [\n            ...u,\n            { timestamp: Date.now(), update: o }\n          ];\n          if (n && w.length >= n) {\n            const b = g(w.map(({ update: k }) => k));\n            w = [{ timestamp: Date.now(), update: b }];\n          }\n          await C(\n            d.put({\n              id: r,\n              updates: w\n            })\n          );\n        } catch (s) {\n          if (!((i = s.message) != null && i.includes(\"The database connection is closing.\")))\n            throw s;\n        }\n      }\n    },\n    disconnect: () => {\n      t().then((r) => r.close()).then(() => {\n        a = null;\n      }).catch(console.error);\n    },\n    cleanup: async () => {\n      await (await t()).clear(\"workspace\");\n    }\n  };\n}, W = (e, n = l) => {\n  const a = T({ dbName: n, mergeCount: v });\n  let t = null;\n  const c = {\n    get status() {\n      return E(t), t.status;\n    },\n    subscribeStatusChange(r) {\n      return E(t), t.subscribeStatusChange(r);\n    },\n    connect: () => {\n      c.connected && c.disconnect(), t = V(e, a, { origin: \"idb\" }), t.connect();\n    },\n    disconnect: () => {\n      a == null || a.disconnect(), t == null || t.disconnect(), t = null;\n    },\n    cleanup: async () => {\n      await (a == null ? void 0 : a.cleanup());\n    },\n    get connected() {\n      return (t == null ? void 0 : t.connected) || !1;\n    },\n    datasource: a\n  };\n  return c;\n}, h = \"snapshot-origin\", j = (e) => (e.preventDefault(), e.returnValue = \"Data is not saved. Are you sure you want to leave?\"), G = async (e) => {\n  window.addEventListener(\"beforeunload\", j, {\n    capture: !0\n  }), await e, window.removeEventListener(\"beforeunload\", j, {\n    capture: !0\n  });\n};\nfunction H(e, n, a) {\n  const t = new A();\n  S(t, n, h);\n  const c = P(e), r = P(t), o = D(\n    e,\n    r\n  ), i = new M(\n    [...t.share.keys()].map((d) => {\n      const u = a(d);\n      if (u === \"Text\")\n        return t.getText(d);\n      if (u === \"Map\")\n        return t.getMap(d);\n      if (u === \"Array\")\n        return t.getArray(d);\n      throw new Error(\"Unknown type\");\n    }),\n    {\n      trackedOrigins: /* @__PURE__ */ new Set([h])\n    }\n  );\n  S(t, o, h), i.undo();\n  const s = D(\n    t,\n    c\n  );\n  S(e, s, h);\n}\nclass J extends Error {\n  constructor() {\n    super(\"Early disconnect\");\n  }\n}\nclass K extends Error {\n  constructor() {\n    super(\"Cleanup when connecting\");\n  }\n}\nconst Q = async (e, n, a, t = l) => {\n  const o = (await p(t, m, {\n    upgrade: f\n  })).transaction(\"milestone\", \"readwrite\").objectStore(\"milestone\"), i = await o.get(\"id\"), s = D(n);\n  i ? (i.milestone[a] = s, await o.put(i)) : await o.put({\n    id: e,\n    milestone: {\n      [a]: s\n    }\n  });\n}, R = async (e, n = l) => {\n  const r = await (await p(n, m, {\n    upgrade: f\n  })).transaction(\"milestone\", \"readonly\").objectStore(\"milestone\").get(e);\n  return r ? r.milestone : null;\n};\nexport {\n  K as CleanupWhenConnectingError,\n  l as DEFAULT_DB_NAME,\n  J as EarlyDisconnectError,\n  T as createIndexedDBDatasource,\n  W as createIndexedDBProvider,\n  m as dbVersion,\n  F as downloadBinary,\n  R as getMilestones,\n  Q as markMilestone,\n  g as mergeUpdates,\n  N as overwriteBinary,\n  _ as pushBinary,\n  H as revertUpdate,\n  z as setMergeCount,\n  q as tryMigrate,\n  f as upgradeDB,\n  G as writeOperation\n};\n//# sourceMappingURL=index.js.map\n"],"file":"assets/index-UxVMN9Je.js"}